import{_ as e,W as t,X as n,Y as o}from"./framework-d3c6dbde.js";const r={},a=o('<p>與過往的程式練習不同，我們不會在執行完結果後結束程式，而是需要維持程式的存活；因此在程式中我們需要一個無窮迴圈讓程式維持不會關閉，同時這個無窮迴圈會處理整個遊戲的輸入、邏輯與畫面三大環節。而這個迴圈我們稱為 <strong>Game Loop</strong></p><h2 id="遊戲迴圈中的邏輯與畫面" tabindex="-1"><a class="header-anchor" href="#遊戲迴圈中的邏輯與畫面" aria-hidden="true">#</a> 遊戲迴圈中的邏輯與畫面</h2><p>在一個遊戲中，會有處理 <strong>邏輯運算</strong> (攻擊傷害計算、移動處理等)的部分 以及 <strong>畫面渲染</strong> 的部分；這兩個部分的處理方式決定遊戲多數情況下能否正常且順利的運行。</p><p>在遊戲中有所謂的 <strong>FPS(Frame per second)</strong> ，這代表遊戲中每秒可以渲染的畫面張數，當遊戲遇到效能瓶頸時我們就必須得犧牲畫面的渲染張數來保證遊戲邏輯的正確。試想，如果今天電腦效能不足以順暢的執行時，我們應該保證 <strong>遊戲傷害計算正確</strong> 還是 <strong>遊戲的FPS不變</strong> ；再進一步思考，如果遊戲的邏輯不再處理，又如何畫出正確的畫面。 因此我們可以總結一個結論</p><blockquote><p>當效能不足時，我們應該優先保障遊戲邏輯的處理</p></blockquote><div class="hint-container warning"><p class="hint-container-title">注意</p><p>如果連邏輯都無法處理的情況我們應該如何處理呢?</p><p>當邏輯無法處理時代表此電腦的配備是低於遊戲所需的最低配備了，因此我們無須考慮此情況</p></div><h2 id="遊戲中的輸入" tabindex="-1"><a class="header-anchor" href="#遊戲中的輸入" aria-hidden="true">#</a> 遊戲中的輸入</h2><p>在遊戲中第二個非常重要的環節就是遊戲的輸入，也就是玩家跟遊戲本身的互動。</p><p>在處理遊戲的輸入時我們要非常注意同步的問題；也就是， <strong>輸入與邏輯應該要是同步而非平行處理</strong> 。</p><p>也就是說，一個遊戲在處理邏輯的時候，如果隨時都有可能收到使用者的輸入，那將有可能導致邏輯的前半段與後半段處理的訊號不同以致於結果混亂遊戲錯誤甚至崩潰；總結來說</p><blockquote><p>在每一次邏輯處理完之前，都不會處理使用者輸入的訊號；訊號一律累積到下一次邏輯處理時進行處理</p></blockquote><h2 id="遊戲核心的開發" tabindex="-1"><a class="header-anchor" href="#遊戲核心的開發" aria-hidden="true">#</a> 遊戲核心的開發</h2><p>在進行Game Loop開發的同時，我們將建置成一個遊戲的核心，並將整個遊戲的 繪圖、邏輯與輸入整併到核心中進行處理；也就是簡單的2D遊戲引擎的創建。</p><p>接下來我們將分為幾個章節來依序建置 -&gt; 繪圖 -&gt; 邏輯 -&gt; 輸入的遊戲核心迴圈</p>',14),s=[a];function p(c,i){return t(),n("div",null,s)}const h=e(r,[["render",p],["__file","index.html.vue"]]);export{h as default};
