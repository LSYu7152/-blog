const e=JSON.parse('{"key":"v-3f2457d8","path":"/java/050002/","title":"Game Loop(Java的遊戲主迴圈)","lang":"zh-TW","frontmatter":{"title":"Game Loop(Java的遊戲主迴圈)","date":"2021-03-18T08:14:16.000Z","permalink":"/java/050002/","category":["Java","Java遊戲開發"],"tag":["程式學習"],"order":2,"description":"與過往的程式練習不同，我們不會在執行完結果後結束程式，而是需要維持程式的存活；因此在程式中我們需要一個無窮迴圈讓程式維持不會關閉，同時這個無窮迴圈會處理整個遊戲的輸入、邏輯與畫面三大環節。而這個迴圈我們稱為 Game Loop 遊戲迴圈中的邏輯與畫面 在一個遊戲中，會有處理 邏輯運算 (攻擊傷害計算、移動處理等)的部分 以及 畫面渲染 的部分；這兩個部分的處理方式決定遊戲多數情況下能否正常且順利的運行。 在遊戲中有所謂的 FPS(Frame per second) ，這代表遊戲中每秒可以渲染的畫面張數，當遊戲遇到效能瓶頸時我們就必須得犧牲畫面的渲染張數來保證遊戲邏輯的正確。試想，如果今天電腦效能不足以順暢的執行時，我們應該保證 遊戲傷害計算正確 還是 遊戲的FPS不變 ；再進一步思考，如果遊戲的邏輯不再處理，又如何畫出正確的畫面。 因此我們可以總結一個結論","head":[["meta",{"property":"og:url","content":"https://www.ed-lin.com/java/050002/"}],["meta",{"property":"og:site_name","content":"Ed Log 工程人日誌"}],["meta",{"property":"og:title","content":"Game Loop(Java的遊戲主迴圈)"}],["meta",{"property":"og:description","content":"與過往的程式練習不同，我們不會在執行完結果後結束程式，而是需要維持程式的存活；因此在程式中我們需要一個無窮迴圈讓程式維持不會關閉，同時這個無窮迴圈會處理整個遊戲的輸入、邏輯與畫面三大環節。而這個迴圈我們稱為 Game Loop 遊戲迴圈中的邏輯與畫面 在一個遊戲中，會有處理 邏輯運算 (攻擊傷害計算、移動處理等)的部分 以及 畫面渲染 的部分；這兩個部分的處理方式決定遊戲多數情況下能否正常且順利的運行。 在遊戲中有所謂的 FPS(Frame per second) ，這代表遊戲中每秒可以渲染的畫面張數，當遊戲遇到效能瓶頸時我們就必須得犧牲畫面的渲染張數來保證遊戲邏輯的正確。試想，如果今天電腦效能不足以順暢的執行時，我們應該保證 遊戲傷害計算正確 還是 遊戲的FPS不變 ；再進一步思考，如果遊戲的邏輯不再處理，又如何畫出正確的畫面。 因此我們可以總結一個結論"}],["meta",{"property":"og:type","content":"article"}],["meta",{"property":"og:locale","content":"zh-TW"}],["meta",{"property":"og:updated_time","content":"2023-03-02T13:04:26.000Z"}],["meta",{"property":"article:tag","content":"程式學習"}],["meta",{"property":"article:published_time","content":"2021-03-18T08:14:16.000Z"}],["meta",{"property":"article:modified_time","content":"2023-03-02T13:04:26.000Z"}],["script",{"type":"application/ld+json"},"{\\"@context\\":\\"https://schema.org\\",\\"@type\\":\\"Article\\",\\"headline\\":\\"Game Loop(Java的遊戲主迴圈)\\",\\"image\\":[\\"\\"],\\"datePublished\\":\\"2021-03-18T08:14:16.000Z\\",\\"dateModified\\":\\"2023-03-02T13:04:26.000Z\\",\\"author\\":[]}"]]},"headers":[{"level":2,"title":"遊戲迴圈中的邏輯與畫面","slug":"遊戲迴圈中的邏輯與畫面","link":"#遊戲迴圈中的邏輯與畫面","children":[]},{"level":2,"title":"遊戲中的輸入","slug":"遊戲中的輸入","link":"#遊戲中的輸入","children":[]},{"level":2,"title":"遊戲核心的開發","slug":"遊戲核心的開發","link":"#遊戲核心的開發","children":[]}],"git":{"createdTime":1677762266000,"updatedTime":1677762266000,"contributors":[{"name":"LSYu7152","email":"k1207152@gmail.com","commits":1}]},"readingTime":{"minutes":2.45,"words":735},"filePathRelative":"java/05.Java遊戲開發/02.Java Game Loop(遊戲主迴圈).md","localizedDate":"2021年3月18日","excerpt":"<p>與過往的程式練習不同，我們不會在執行完結果後結束程式，而是需要維持程式的存活；因此在程式中我們需要一個無窮迴圈讓程式維持不會關閉，同時這個無窮迴圈會處理整個遊戲的輸入、邏輯與畫面三大環節。而這個迴圈我們稱為 <strong>Game Loop</strong></p>\\n<h2> 遊戲迴圈中的邏輯與畫面</h2>\\n<p>在一個遊戲中，會有處理 <strong>邏輯運算</strong> (攻擊傷害計算、移動處理等)的部分 以及 <strong>畫面渲染</strong> 的部分；這兩個部分的處理方式決定遊戲多數情況下能否正常且順利的運行。</p>\\n<p>在遊戲中有所謂的 <strong>FPS(Frame per second)</strong> ，這代表遊戲中每秒可以渲染的畫面張數，當遊戲遇到效能瓶頸時我們就必須得犧牲畫面的渲染張數來保證遊戲邏輯的正確。試想，如果今天電腦效能不足以順暢的執行時，我們應該保證 <strong>遊戲傷害計算正確</strong> 還是 <strong>遊戲的FPS不變</strong> ；再進一步思考，如果遊戲的邏輯不再處理，又如何畫出正確的畫面。 因此我們可以總結一個結論</p>","autoDesc":true}');export{e as data};
